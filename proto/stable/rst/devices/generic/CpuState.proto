syntax = "proto2";

package rst.devices.generic;

import "rst/Unit.proto";

option java_outer_classname = "CpuStateType";

/**
 * Low-level information of the CPU utilization for a single system with
 * potentially multiple cores.
 *
 * This message is currently designed closely along the information available
 * in the Linux proc filesystem. So it is probably only directly useful for
 * Linux systems.
 *
 * @author Jens-Christian Seele <jseele@techfak.uni-bielefeld.de>
 * @author Johannes Wienke <jwienke@techfak.uni-bielefeld.de>
 */
// @create_collection
message CpuState {

    /**
     * The length of one measurement tick for the individual CPU counters.
     */
    optional uint32 jiffy_length = 10 [ (rst.unit) = "microsecond" ];

    /**
     * Measurements for a single CPU in the system.
     *
     * The supported detailed fields for each CPU vary with different Kernel
     * versions. In oder to calculate at least a valid load of the CPU,
     * minimally total and idle need to be given. Hence, they are required
     * fields. Ideally, @ref .idle + all other detail fields should sum up to
     * the total value.
     *
     * With each new measurement all counters must fulfill the condition
     * new value >= previous value. I.e. these are ever-increasing numbers and
     * differences need to be calculated to find out the current system
     * statistics.
     *
     * All values are measured in abstract ticks of a fixed length. This length
     * is specified @ref CpuState.jiffy_length.
     */
    message Cpu {

        /**
         * Identifier for the respective CPU or core in a multicore system.
         */
        required int32 index = 1 [ (rst.unit) = "number" ];

        /**
         * Total time spent by this CPU so far in any mode including idle.
         */
        required uint64 total = 100 [ (rst.unit) = "number" ];

        /**
         * Time spent idle.
         */
        required uint64 idle = 5 [ (rst.unit) = "number" ];

        /**
         * Time spent in user mode.
         */
        optional uint64 user = 2 [ (rst.unit) = "number" ];

        /**
         * Time spent in user mode with nice (low) priority.
         */
        optional uint64 user_low = 3 [ (rst.unit) = "number" ];

        /**
         * Time spent in system mode.
         */
        optional uint64 system = 4 [ (rst.unit) = "number" ];

        /**
         * Time spent waiting for IO to complete.
         */
        optional uint64 iowait = 6 [ (rst.unit) = "number" ];

        /**
         * Time spent servicing interrupts.
         */
        optional uint64 irq = 7 [ (rst.unit) = "number" ];

        /**
         * Time spent servicing softirqs.
         */
        optional uint64 softirq = 8 [ (rst.unit) = "number" ];

        /**
         * Time spent in another operating system in case of a virtualized system.
         */
        optional uint64 steal = 9 [ (rst.unit) = "number" ];

        /**
         * Time spent running a virtualized guest.
         */
        optional uint64 guest = 10 [ (rst.unit) = "number" ];

    }

    /**
     * An entry for each (virtualized) CPU or core of a multicore system.
     */
    repeated Cpu cpus = 20;

    /**
     * Load average for one minute as defined by the linux kernel, e.g. in
     * man proc:
     * The first three fields in this file are load average figures giving the
     * number of jobs in the run queue (state R) or waiting for disk I/O
     * (state D) averaged over 1, 5, and 15 minutes
     */
    // @constraint(value>=0)
    optional float load_1 = 40 [ (rst.unit) = "number" ];

    /**
     * Load average for 5 minutes as defined by the linux kernel, e.g. in
     * man proc:
     * The first three fields in this file are load average figures giving the
     * number of jobs in the run queue (state R) or waiting for disk I/O
     * (state D) averaged over 1, 5, and 15 minutes
     */
    // @constraint(value>=0)
    optional float load_5 = 41 [ (rst.unit) = "number" ];

    /**
     * Load average for 15 minute as defined by the linux kernel, e.g. in
     * man proc:
     * The first three fields in this file are load average figures giving the
     * number of jobs in the run queue (state R) or waiting for disk I/O
     * (state D) averaged over 1, 5, and 15 minutes
     */
    // @constraint(value>=0)
    optional float load_15 = 42 [ (rst.unit) = "number" ];

}
